/**
 * @license
 * Copyright 2017 Yahoo Inc. All rights reserved.
 * Modifications Copyright 2020 Yosep Lee.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"os"

	"crypto/sha512"
	"errors"
	"math/big"

	"github.com/busimus/prover/edwards25519"
	"golang.org/x/crypto/sha3"
)

const (
	limit    = 100
	N2       = 32 // ceil(log2(q) / 8)
	N        = N2 / 2
	qs       = "1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed" // 2^252 + 27742317777372353535851937790883648493
	cofactor = 8
	NOSIGN   = 3
)

var (
	ErrMalformedInput = errors.New("ECVRF: malformed input")
	ErrDecodeError    = errors.New("ECVRF: decode error")
	ErrInternalError  = errors.New("ECVRF: internal error")
	q, _              = new(big.Int).SetString(qs, 16)
	g                 = ge()
)

const (
	// PublicKeySize is the size, in bytes, of public keys as used in this package.
	PublicKeySize = 32
	// PrivateKeySize is the size, in bytes, of private keys as used in this package.
	PrivateKeySize = 64
	// SignatureSize is the size, in bytes, of signatures generated and verified by this package.
	SignatureSize = 64
)

// assume <pk, sk> were generated by ed25519.GenerateKey()
// Prove generates vrf output and corresponding proof(pi) with secret key
func Prove(pk []byte, sk []byte, m []byte) (pi, hash []byte, err error) {
	x := expandSecret(sk)
	h := hashToCurve(m, pk)
	r := ecp2OS(geScalarMult(h, x))

	kp, ks, err := ed25519.GenerateKey(nil) // use GenerateKey to generate a random
	if err != nil {
		return nil, nil, err
	}
	k := expandSecret(ks)

	// hashPoints(g, h, g^x, h^x, g^k, h^k)
	c := hashPoints(ecp2OS(g), ecp2OS(h), s2OS(pk), r, s2OS(kp), ecp2OS(geScalarMult(h, k)))

	// s = k - c*x mod q
	var z big.Int
	s := z.Mod(z.Sub(f2IP(k), z.Mul(c, f2IP(x))), q)

	// pi = gamma || i2OSP(c, N) || i2OSP(s, 2N)
	var buf bytes.Buffer
	buf.Write(r) // 2N
	buf.Write(i2OSP(c, N))
	buf.Write(i2OSP(s, N2))
	pi = buf.Bytes()
	return pi, Hash(pi), nil
}

// Hash converts proof(pi) into vrf output(hash) without verifying it
func Hash(pi []byte) []byte {
	return pi[1 : N2+1]
}

// Verify checks if the proof is correct or not
func Verify(pk []byte, pi []byte, m []byte) (bool, error) {
	r, c, s, err := decodeProof(pi)
	if err != nil {
		return false, err
	}
	// return true, nil

	// u = (g^x)^c * g^s = P^c * g^s
	var u edwards25519.ProjectiveGroupElement
	P := os2ECP(pk, pk[31]>>7)
	if P == nil {
		return false, ErrMalformedInput
	}
	edwards25519.GeDoubleScalarMultVartime(&u, c, P, s)
	// fmt.Println("u", u)
	// fmt.Println("c", hex.EncodeToString(c[:]))
	// fmt.Println("P", P)
	// fmt.Println("s", hex.EncodeToString(s[:]))

	h := hashToCurve(m, pk)
	// fmt.Println("hashToCurved")
	// fmt.Println("h", h)
	// return false, nil
	// return false, nil

	// v = gamma^c * h^s
	//	fmt.Printf("c, r, s, h\n%s%s%s%s\n", hex.Dump(c[:]), hex.Dump(ecp2OS(r)), hex.Dump(s[:]), hex.Dump(ecp2OS(h)))
	m1 := geScalarMult(r, c)
	m2 := geScalarMult(h, s)
	// fmt.Println("m1", m1)
	// fmt.Println("m2", m2)
	v := geAdd(m1, m2)
	// fmt.Println("v", v)

	// c' = hashPoints(g, h, g^x, gamma, u, v)
	// fmt.Println("g", g)
	c2 := hashPoints(ecp2OS(g), ecp2OS(h), s2OS(pk), ecp2OS(r), ecp2OSProj(&u), ecp2OS(v))
	// fmt.Println("hashPointsed")
	// fmt.Println("c2", c2)
	// fmt.Println("c", hex.EncodeToString(c[:]))
	// fmt.Println("cF", f2IP(c))

	return c2.Cmp(f2IP(c)) == 0, nil
}

func decodeProof(pi []byte) (r *edwards25519.ExtendedGroupElement, c *[N2]byte, s *[N2]byte, err error) {
	i := 0
	sign := pi[i]
	i++
	if sign != 2 && sign != 3 {
		return nil, nil, nil, ErrDecodeError
	}
	r = os2ECP(pi[i:i+N2], sign-2)
	i += N2
	if r == nil {
		return nil, nil, nil, ErrDecodeError
	}

	// swap and expand to make it a field
	c = new([N2]byte)
	for j := N - 1; j >= 0; j-- {
		c[j] = pi[i]
		i++
	}

	// swap to make it a field
	s = new([N2]byte)
	for j := N2 - 1; j >= 0; j-- {
		s[j] = pi[i]
		i++
	}
	return
}

func hashPoints(ps ...[]byte) *big.Int {
	h := sha3.NewLegacyKeccak256()
	//h := sha256.New()
	//	fmt.Printf("hash_points:\n")
	for _, p := range ps {
		h.Write(p)
		// fmt.Println("ps", i+1, hex.EncodeToString(p))
	}
	v := h.Sum(nil)
	// fmt.Println("hash", hex.EncodeToString(v))
	// fmt.Println("val", hex.EncodeToString(v[:N]))
	return os2IP(v[:N])
}

func hashToCurve(m []byte, pk []byte) *edwards25519.ExtendedGroupElement {
	// fmt.Println("hashToCurve")
	// fmt.Println("m", hex.EncodeToString(m))
	// fmt.Println("pk", hex.EncodeToString(pk))
	hash := sha3.NewLegacyKeccak256()
	for i := int64(0); i < limit; i++ {
		var buf bytes.Buffer
		ctr := i2OSP(big.NewInt(i), 4)
		// hash.Write(m)
		// hash.Write(pk)
		// hash.Write(ctr)
		buf.Write(m)
		buf.Write(pk)
		buf.Write(ctr)
		hash.Write(buf.Bytes())
		h := hash.Sum(nil)
		hash.Reset()
		// fmt.Println("buf", i, hex.EncodeToString(buf.Bytes()))
		// fmt.Println("hash", i, hex.EncodeToString(h))
		if P := os2ECP(h, NOSIGN); P != nil {
			// fmt.Println("P", P)
			// assume cofactor is 2^n
			for j := 1; j < cofactor; j *= 2 {
				P = geDouble(P)
			}
			return P
		}
	}
	panic("hashToCurve: couldn't make a point on curve")
}

func os2ECP(os []byte, sign byte) *edwards25519.ExtendedGroupElement {
	P := new(edwards25519.ExtendedGroupElement)
	var buf [32]byte
	copy(buf[:], os)
	if sign == 0 || sign == 1 {
		buf[31] = (sign << 7) | (buf[31] & 0x7f)
	}
	// fmt.Println("os2ECP buf", hex.EncodeToString(buf[:]))
	if !P.FromBytes(&buf) {
		return nil
	}
	return P
}

// just prepend the sign octet
func s2OS(s []byte) []byte {
	sign := s[31] >> 7     // @@ we should clear the sign bit??
	os := []byte{sign + 2} // Y = 0x02 if positive or 0x03 if negative
	os = append([]byte(os), s...)
	return os
}

func ecp2OS(P *edwards25519.ExtendedGroupElement) []byte {
	var s [32]byte
	P.ToBytes(&s)
	return s2OS(s[:])
}

func ecp2OSProj(P *edwards25519.ProjectiveGroupElement) []byte {
	var s [32]byte
	P.ToBytes(&s)
	return s2OS(s[:])
}

func i2OSP(b *big.Int, n int) []byte {
	os := b.Bytes()
	if n > len(os) {
		var buf bytes.Buffer
		buf.Write(make([]byte, n-len(os))) // prepend 0s
		buf.Write(os)
		return buf.Bytes()
	} else {
		return os[:n]
	}
}

func os2IP(os []byte) *big.Int {
	return new(big.Int).SetBytes(os)
}

// convert a field number (in LittleEndian) to a big int
func f2IP(f *[32]byte) *big.Int {
	var t [32]byte
	for i := 0; i < 32; i++ {
		t[32-i-1] = f[i]
	}
	return os2IP(t[:])
}

func ip2F(b *big.Int) *[32]byte {
	os := b.Bytes()
	r := new([32]byte)
	j := len(os) - 1
	for i := 0; i < 32 && j >= 0; i++ {
		r[i] = os[j]
		j--
	}
	return r
}

func ge() *edwards25519.ExtendedGroupElement {
	g := new(edwards25519.ExtendedGroupElement)
	var f edwards25519.FieldElement
	edwards25519.FeOne(&f)
	var s [32]byte
	edwards25519.FeToBytes(&s, &f)
	// fmt.Println("ge s", hex.EncodeToString(s[:]))
	edwards25519.GeScalarMultBase(g, &s) // g = g^1
	return g
}

func expandSecret(sk []byte) *[32]byte {
	// copied from golang.org/x/crypto/ed25519/ed25519.go -- has to be the same
	digest := sha512.Sum512(sk[:32])
	digest[0] &= 248
	digest[31] &= 127
	digest[31] |= 64
	h := new([32]byte)
	copy(h[:], digest[:])
	return h
}

// copied from edwards25519.go and const.go in golang.org/x/crypto/ed25519/internal/edwards25519
type CachedGroupElement struct {
	yPlusX, yMinusX, Z, T2d edwards25519.FieldElement
}

// d2 is 2*d.
var d2 = edwards25519.FieldElement{
	-21827239, -5839606, -30745221, 13898782, 229458, 15978800, -12551817, -6495438, 29715968, 9444199,
}

func toCached(r *CachedGroupElement, p *edwards25519.ExtendedGroupElement) {
	edwards25519.FeAdd(&r.yPlusX, &p.Y, &p.X)
	edwards25519.FeSub(&r.yMinusX, &p.Y, &p.X)
	edwards25519.FeCopy(&r.Z, &p.Z)
	edwards25519.FeMul(&r.T2d, &p.T, &d2)
}

func geAdd(p, qe *edwards25519.ExtendedGroupElement) *edwards25519.ExtendedGroupElement {
	var q CachedGroupElement
	var r edwards25519.CompletedGroupElement
	var t0 edwards25519.FieldElement

	toCached(&q, qe)

	edwards25519.FeAdd(&r.X, &p.Y, &p.X)
	edwards25519.FeSub(&r.Y, &p.Y, &p.X)
	edwards25519.FeMul(&r.Z, &r.X, &q.yPlusX)
	edwards25519.FeMul(&r.Y, &r.Y, &q.yMinusX)
	edwards25519.FeMul(&r.T, &q.T2d, &p.T)
	edwards25519.FeMul(&r.X, &p.Z, &q.Z)
	edwards25519.FeAdd(&t0, &r.X, &r.X)
	edwards25519.FeSub(&r.X, &r.Z, &r.Y)
	edwards25519.FeAdd(&r.Y, &r.Z, &r.Y)
	edwards25519.FeAdd(&r.Z, &t0, &r.T)
	edwards25519.FeSub(&r.T, &t0, &r.T)

	re := new(edwards25519.ExtendedGroupElement)
	r.ToExtended(re)
	return re
}

func geDouble(p *edwards25519.ExtendedGroupElement) *edwards25519.ExtendedGroupElement {
	var q edwards25519.ProjectiveGroupElement
	p.ToProjective(&q)
	// // fmt.Println("geDouble q", q)
	var rc edwards25519.CompletedGroupElement
	q.Double(&rc)
	// // fmt.Println("geDouble rc", rc)
	r := new(edwards25519.ExtendedGroupElement)
	rc.ToExtended(r)
	// // fmt.Println("geDouble r", r)
	return r
}

func extendedGroupElementCMove(t, u *edwards25519.ExtendedGroupElement, b int32) {
	edwards25519.FeCMove(&t.X, &u.X, b)
	edwards25519.FeCMove(&t.Y, &u.Y, b)
	edwards25519.FeCMove(&t.Z, &u.Z, b)
	edwards25519.FeCMove(&t.T, &u.T, b)
}

func geScalarMult(h *edwards25519.ExtendedGroupElement, a *[32]byte) *edwards25519.ExtendedGroupElement {
	q := new(edwards25519.ExtendedGroupElement)
	q.Zero()
	p := h
	for i := uint(0); i < 256; i++ {
		bit := int32(a[i>>3]>>(i&7)) & 1
		t := geAdd(q, p)
		extendedGroupElementCMove(q, t, bit)
		p = geDouble(p)
	}
	return q
}

func TestVRF(pk, sk []byte, msg []byte, verbose bool) (pi []byte, hash []byte) {
	pi, hash, err := Prove(pk, sk, msg[:])
	if err != nil {
		panic(err)
	}
	res, err := Verify(pk, pi, msg[:])
	if err != nil {
		panic(err)
	}
	if !res {
		panic("VRF failed")
	}

	// when everything get through
	if verbose {
		fmt.Printf("msg: %s\n", hex.EncodeToString(msg))
		fmt.Printf("SK:  %s\n", hex.EncodeToString(sk))
		fmt.Printf("PK:  %s\n", hex.EncodeToString(pk))
		fmt.Printf("pi:  %s\n", hex.EncodeToString(pi))
		fmt.Printf("vrf: %s\n", hex.EncodeToString(Hash(pi)))

		// r, c, s, err := decodeProof(pi)
		// if err != nil {
		// 	panic(err)
		// }
		// // u = (g^x)^c * g^s = P^c * g^s
		// var u ed1.ProjectiveGroupElement
		// P := os2ECP(pk, pk[31]>>7)
		// ed1.GeDoubleScalarMultVartime(&u, c, P, s)
		// fmt.Printf("\nr: %s\n", hex.EncodeToString(ecp2OS(r)))
		// fmt.Printf("c: %s\n", hex.EncodeToString(c[:]))
		// fmt.Printf("s: %s\n", hex.EncodeToString(s[:]))
		// fmt.Printf("u: %s\n", hex.EncodeToString(ecp2OSProj(&u)))
	}
	return
}

func TestVRFVerify(pk []byte, pi []byte, msg []byte, verbose bool) {
	_, err := Verify(pk, pi, msg[:])
	if err != nil {
		panic(err)
	}

	if verbose {
		fmt.Printf("msg: %s\n", hex.EncodeToString(msg))
		fmt.Printf("PK:  %s\n", hex.EncodeToString(pk))
		fmt.Printf("pi:  %s\n", hex.EncodeToString(pi))
		fmt.Printf("vrf: %s\n", hex.EncodeToString(Hash(pi)))

		// r, c, s, err := decodeProof(pi)
		// if err != nil {
		// 	panic(err)
		// }
		// // u = (g^x)^c * g^s = P^c * g^s
		// var u ed1.ProjectiveGroupElement
		// P := os2ECP(pk, pk[31]>>7)
		// ed1.GeDoubleScalarMultVartime(&u, c, P, s)
		// fmt.Printf("\nr: %s\n", hex.EncodeToString(ecp2OS(r)))
		// fmt.Printf("c: %s\n", hex.EncodeToString(c[:]))
		// fmt.Printf("s: %s\n", hex.EncodeToString(s[:]))
		// fmt.Printf("u: %s\n", hex.EncodeToString(ecp2OSProj(&u)))
	}
}

const (
	PK  = "cd44e3b99b008a2140a81908dbe9577a50963d1080662d5d17c1c80cfe69187b"
	SK  = "cb4bfbe4ba64c3cb0299d6a88ccffd4bc3ff47b912fbf2e8c0e0d406d3f3f089cd44e3b99b008a2140a81908dbe9577a50963d1080662d5d17c1c80cfe69187b"
	MSG = "544553545f4d4553534147455f544553545f4d4553534147455f544553545f4d"
	PI  = "03867462fc7eeff5ae6e6b798263c6258464e623569aaa5b4e23c8e46a8d6dcb9da977eb0029201a21d0d52feb55948a5d0a48c08979731652f44fd42cea0034e7ce6993e4c280258b159f07f5c0199eb3"
)

func prove(msgInput string) {
	pk, _ := hex.DecodeString(PK)
	sk, _ := hex.DecodeString(SK)
	msg, _ := hex.DecodeString(msgInput)
	pi, hash, err := Prove(pk, sk, msg)
	if err != nil {
		panic(err)
	}
	fmt.Printf("pi:  %s\n", hex.EncodeToString(pi))
	fmt.Printf("vrf: %s\n", hex.EncodeToString(hash))
}

func testVerify() {
	pk, _ := hex.DecodeString(PK)
	msg, _ := hex.DecodeString(MSG)
	pi, _ := hex.DecodeString(PI)
	TestVRFVerify(pk, pi, msg[:], false)
}

type testTypes struct {
	Verify validCases `json:"verify"`
}

type validCases struct {
	Valid []testCase `json:"valid"`
}

type testCase struct {
	// Pk     string `json:"pk"`
	// Sk     string `json:"sk"`
	// Msg    string `json:"msg"`
	// Proof  string `json:"proof"`
	Hash string `json:"hash"`
	// Result bool   `json:"result"`
}

func generateCases() {
	// array of valid test cases
	var validCases = validCases{}
	for i := 0; i < 1000; i++ {
		pk, sk, err := ed25519.GenerateKey(nil)
		if err != nil {
			panic(err)
		}
		var msgFull [32]byte
		io.ReadFull(rand.Reader, msgFull[:])
		// trim msg to random length
		length, _ := rand.Int(rand.Reader, big.NewInt(int64(len(msgFull))-2))
		msg := msgFull[:length.Int64()+2]
		_, hash := TestVRF(pk, sk, msg[:], false)

		// create test case struct
		tc := testCase{
			// Pk:     "0x" + hex.EncodeToString(pk),
			// Sk:     "0x" + hex.EncodeToString(sk),
			// Msg:    "0x" + hex.EncodeToString(msg[:]),
			// Proof:  "0x" + hex.EncodeToString(proof),
			Hash: "0x" + hex.EncodeToString(hash),
			// Result: true,
		}
		validCases.Valid = append(validCases.Valid, tc)
	}
	allTestTypes := testTypes{
		Verify: validCases,
	}
	// save valid cases to json file
	validCasesJSON, err := json.MarshalIndent(allTestTypes, "", "  ")
	if err != nil {
		panic(err)
	}
	err = os.WriteFile("validCases.json", validCasesJSON, 0644)
	if err != nil {
		panic(err)
	}
}
